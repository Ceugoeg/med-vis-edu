# ⚠️ 致 A 的交接文档（极其重要，动键盘前必看！）
> from Gemini 人情味版本
> 2026.2.22 14:00

兄弟，前端的骨架我已经强行跑通了。B 那个模型导出来连顶点法线都没有（一片黑），名字也是乱码，我都已经在 `app.js` 里写了兜底代码硬算、硬改过来了。

**所以现在的核心诉求：** 我的前端部分目前稳如老狗，你接下来接入摄像头的时候，**千万、千万、千万不要让 Agent 顺手改掉我 `app.js` 里的任何逻辑和文件引用路径！**

你接下来的任务非常纯粹，不需要管 3D 渲染，只需要把 MediaPipe 跑起来，然后像一个无情的发报机一样，给我吐出以下数据就行：

## 1. 唯一的数据交接点：`window.handData`

你只要在你的代码里，每帧往全局的 `window.handData` 里塞数据就行。我的代码会自己去这里拿。
**这个对象的字段名、数据类型必须严格如下，一个字母都不能差**：

```javascript
// 你的代码每帧必须输出这样的结构给全局：
window.handData = {
  // 只能是这四个字符串之一，严格大写！
  state: 'PINCH', // 可选值: 'OPEN' | 'FIST' | 'PINCH' | 'NONE'
  
  // 必须是 21 个点的数组，且 x,y,z 必须是 [0, 1] 归一化后的浮点数
  landmarks: [
    { x: 0.12, y: 0.34, z: 0.05 }, // 第 0 个点 (手腕)
    { x: 0.15, y: 0.30, z: 0.04 }, // 第 1 个点
    // ... 一直到第 20 个点，共21个点
  ],
  
  // 识别的置信度 (0 到 1)
  confidence: 0.95
};

```

## 2. 必须做的一阶滞后滤波（防帕金森警告）

兄弟，摄像头的原始坐标一定会抖。如果你不加处理直接扔给我，我的 3D 心脏在屏幕上就会像得了帕金森一样疯狂抽搐。

请一定要在输出 `landmarks` 之前，套一层我们在操作手册里定好的**一阶滞后滤波**（权重  推荐设为 `0.2`）。
伪代码逻辑如下（你可以直接扔给 Cursor 让它帮你补全）：

```javascript
// alpha 越小，平滑效果越强，但延迟越大。0.2 是个不错的初始值
const alpha = 0.2; 
let smoothedLandmarks = [];

// 假设 currentRawLandmarks 是你这帧刚从 MediaPipe 拿到的原始数据
for (let i = 0; i < 21; i++) {
  smoothedLandmarks[i].x = alpha * currentRawLandmarks[i].x + (1 - alpha) * lastFrameLandmarks[i].x;
  // y 和 z 同理...
}
// 最后把 smoothedLandmarks 塞进 window.handData

```

## 3. 终极 Checklist

提 PR 或者合并代码前，请务必核对：

* [ ] 你的逻辑是否完全独立？（只新增了识别脚本，**绝对没有**改动我的 `app.js` 里的材质、光照和命名逻辑）
* [ ] 输出的 `state` 状态是否极其稳定？（不抖动，不会在 'OPEN' 和 'NONE' 之间反复横跳）
* [ ] 滤波算法加上了吗？

搞定这些，剩下的 3D 交互和射线碰撞就交给我了。冲！
